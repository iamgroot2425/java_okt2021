package de.lubowiecki.ocp.basics;

public class DatentypenTest {
	
	public static void main(String[] args) {
		
		int i = 10; // Die 10 vor der Zuweisung ist ein Literal
		Math.abs(10.0); // 10.0 ist ein Literal
		String s = "ABC"; // "ABC" ist ein String-Literal
		
		byte j = 10;
		doSomething(j);
		
		doSomething(10); // Ganzzahlen-Literale sind immer vom Typ int
		doSomething(10.5); // ReeleZahlen-Literale sind immer vom Typ double
		
		if(true) { // true: Boolean-Literal
			//...
		}
		
		long l1 = 100; // widening von int zu long 
		//long l2 = 10000000000; // Error: das literal ist noch ein int 
		long l3 = 1_00_00_00_00_00L; // das literal ist jetzt wirklich ein long
		
		int z = 10; // Dezimal
		System.out.println(z);
		
		z = 017; // Oktal
		System.out.println(z); // 15
		
		z = 0b1001; // Binär
		System.out.println(z); // 9
		
		z = 0x10; // Hex
		System.out.println(z); // 16
		
		float f = 10.0f; // f muss ran, da das Literal sonst ein double ist und damit zu groß
		
//		byte < short < int < long < float < double
//				char < int
		
		double d = 'b';
		System.out.println(d);
		
		System.out.println();
		
		
		// Lex-Ordnung: Sonderzeichen, Zahlen, Großbuchstaben, Kleinbuchstaben, Restliche-Sonderzeichen
		System.out.println( (int) 'a');
		System.out.println( (int) 'A');
		System.out.println( (int) '1');
		System.out.println( (int) '#');
		
		// == für primitive vergleicht den Wert
		// == für Objekte vergleicht, ob die Referenzen auf das gleiche Objekt auf dem Heap zeigen
		// equals für Objekte vergleicht den Inhalt
		
		
		byte b = 1;
		short s1 = 1;
		int erg = b + s1; // Mathematische Operation hebt beide auf den gleichen Typ an, mind. int
		
		short erg2 = (short)(b + s1); // Casting von int auf short, kann zu einem underflow oder overflow führen
		
		byte b1 = (byte)128L; // overflow
		System.out.println(b1);
		
		byte b2 = 10;
		b2++; // b2 = (byte) (b2 + 1);
		// b2++, ++b2, --b2, b2--
		b2 += 10; // b2 = (byte) (b2 + 10);
		
		int x;
		//System.out.println(x); // Error: Nicht initialisierte lokale Variablen dürfen nicht lesend verwendet werden
		
		// links: Referenztyp
		// rechts: Objekttyp
		Person p = new Person();
		Object o = new Person();
	}
	
//	public static void doSomething(byte wert) {
//		System.out.println(wert);
//	}
//	
//	public static void doSomething(int wert) {
//		System.out.println(wert);
//	}
	
	public static void doSomething(double wert) {
		System.out.println(wert);
	}

}
